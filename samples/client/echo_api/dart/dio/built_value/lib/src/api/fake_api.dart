//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

import 'dart:async';
import 'package:dio/dio.dart';
import 'package:built_value/built_value.dart';
import 'package:built_collection/built_collection.dart';
import 'package:built_value/serializer.dart';
import 'package:openapi/src/repository_base.dart';
import 'package:openapi/src/api_util.dart';
import 'package:openapi/models.dart';
import 'dart:typed_data';
import 'package:built_collection/built_collection.dart';
import 'package:openapi/src/model/date.dart';
import 'package:openapi/src/model/file_schema_test_class.dart';
import 'package:openapi/src/model/health_check_result.dart';
import 'package:openapi/src/model/model_client.dart';
import 'package:openapi/src/model/model_enum_class.dart';
import 'package:openapi/src/model/outer_composite.dart';
import 'package:openapi/src/model/outer_object_with_enum_property.dart';
import 'package:openapi/src/model/pet.dart';
import 'package:openapi/src/model/user.dart';

part 'fake_api.g.dart';

class FakeApi {

  final FakeApiRaw rawApi;
  final SerializationRepositoryBase _repository;

  const FakeApi(this.rawApi, this._repository);

  /// Health check endpoint
  /// 
  ///
  /// Parameters:
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [HealthCheckResult] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<HealthCheckResult>> fakeHealthGet({ 
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    

    final _response = await rawApi.fakeHealthGet(
      

      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    HealthCheckResult? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    HealthCheckResult
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<HealthCheckResult>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// test http signature authentication
  /// 
  ///
  /// Parameters:
  /// * [pet] - Pet object that needs to be added to the store
  /// * [query1] - query parameter
  /// * [header1] - header parameter
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> fakeHttpSignatureTest({ 
    required Pet pet,
    required String query1,
    required String header1,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, pet, const TypeInfo(
        
    
    Pet
    )

);    

    final _response = await rawApi.fakeHttpSignatureTest(
      
      query1: encodeQueryParameter(_repository, query1, const TypeInfo(
        
    
    String
    )

, )!,
      header1: encodeStringParameter(_repository, header1, const TypeInfo(
        
    
    String
    )

,)!, 
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// fakeOuterBooleanSerialize
  /// Test serialization of outer boolean types
  ///
  /// Parameters:
  /// * [body] - Input boolean as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [bool] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<bool>> fakeOuterBooleanSerialize({ 
    required bool body,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, body, const TypeInfo(
        
    
    bool
    )

);    

    final _response = await rawApi.fakeOuterBooleanSerialize(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    bool? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    bool
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<bool>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// fakeOuterCompositeSerialize
  /// Test serialization of object with outer number type
  ///
  /// Parameters:
  /// * [outerComposite] - Input composite as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [OuterComposite] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<OuterComposite>> fakeOuterCompositeSerialize({ 
    required OuterComposite outerComposite,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, outerComposite, const TypeInfo(
        
    
    OuterComposite
    )

);    

    final _response = await rawApi.fakeOuterCompositeSerialize(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    OuterComposite? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    OuterComposite
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<OuterComposite>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// fakeOuterNumberSerialize
  /// Test serialization of outer number types
  ///
  /// Parameters:
  /// * [body] - Input number as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [num] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<num>> fakeOuterNumberSerialize({ 
    required num body,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, body, const TypeInfo(
        
    
    num
    )

);    

    final _response = await rawApi.fakeOuterNumberSerialize(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    num? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    num
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<num>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// fakeOuterStringSerialize
  /// Test serialization of outer string types
  ///
  /// Parameters:
  /// * [body] - Input string as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [String] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<String>> fakeOuterStringSerialize({ 
    required String body,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, body, const TypeInfo(
        
    
    String
    )

);    

    final _response = await rawApi.fakeOuterStringSerialize(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    String? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    String
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<String>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// fakePropertyEnumIntegerSerialize
  /// Test serialization of enum (int) properties with examples
  ///
  /// Parameters:
  /// * [outerObjectWithEnumProperty] - Input enum (int) as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [OuterObjectWithEnumProperty] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<OuterObjectWithEnumProperty>> fakePropertyEnumIntegerSerialize({ 
    required OuterObjectWithEnumProperty outerObjectWithEnumProperty,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, outerObjectWithEnumProperty, const TypeInfo(
        
    
    OuterObjectWithEnumProperty
    )

);    

    final _response = await rawApi.fakePropertyEnumIntegerSerialize(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    OuterObjectWithEnumProperty? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    OuterObjectWithEnumProperty
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<OuterObjectWithEnumProperty>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// testBodyWithBinary
  /// For this test, the body has to be a binary file.
  ///
  /// Parameters:
  /// * [body] - image to upload
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testBodyWithBinary({ 
    required MultipartFile? body,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, body, const TypeInfo.nullable(
        
    
    MultipartFile
    )

);    

    final _response = await rawApi.testBodyWithBinary(
      
      body: _bodyData,
      requestContentType: 'image/png',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// testBodyWithFileSchema
  /// For this test, the body for this request must reference a schema named &#x60;File&#x60;.
  ///
  /// Parameters:
  /// * [fileSchemaTestClass] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testBodyWithFileSchema({ 
    required FileSchemaTestClass fileSchemaTestClass,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, fileSchemaTestClass, const TypeInfo(
        
    
    FileSchemaTestClass
    )

);    

    final _response = await rawApi.testBodyWithFileSchema(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// testBodyWithQueryParams
  /// 
  ///
  /// Parameters:
  /// * [query] 
  /// * [user] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testBodyWithQueryParams({ 
    required String query,
    required User user,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, user, const TypeInfo(
        
    
    User
    )

);    

    final _response = await rawApi.testBodyWithQueryParams(
      
      query: encodeQueryParameter(_repository, query, const TypeInfo(
        
    
    String
    )

, )!,
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// To test \&quot;client\&quot; model
  /// To test \&quot;client\&quot; model
  ///
  /// Parameters:
  /// * [modelClient] - client model
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [ModelClient] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<ModelClient>> testClientModel({ 
    required ModelClient modelClient,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, modelClient, const TypeInfo(
        
    
    ModelClient
    )

);    

    final _response = await rawApi.testClientModel(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    ModelClient? _responseData;

    try {
      final rawResponse = _response.data;
       _responseData = rawResponse == null ? null : await decodeResponse(_repository, rawResponse, const TypeInfo(
        
    ModelClient
    
    )

);     
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<ModelClient>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
  /// Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
  ///
  /// Parameters:
  /// * [number] - None
  /// * [double_] - None
  /// * [patternWithoutDelimiter] - None
  /// * [byte] - None
  /// * [integer] - None
  /// * [int32] - None
  /// * [int64] - None
  /// * [float] - None
  /// * [string] - None
  /// * [binary] - None
  /// * [date] - None
  /// * [dateTime] - None
  /// * [password] - None
  /// * [callback] - None
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testEndpointParameters({ 
    required num number,
    required double double_,
    required String patternWithoutDelimiter,
    required String byte,
    required int integer,
    required int int32,
    required int int64,
    required double float,
    required String string,
    required Uint8List binary,
    required Date date,
    required DateTime dateTime,
    required String password,
    required String callback,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    final _bodyMap = <String, dynamic>{
      if (integer != null) r'integer': encodeFormParameter(_repository, integer, const TypeInfo(
        
    
    int
    )

),
      if (int32 != null) r'int32': encodeFormParameter(_repository, int32, const TypeInfo(
        
    
    int
    )

),
      if (int64 != null) r'int64': encodeFormParameter(_repository, int64, const TypeInfo(
        
    
    int
    )

),
      r'number': encodeFormParameter(_repository, number, const TypeInfo(
        
    
    num
    )

),
      if (float != null) r'float': encodeFormParameter(_repository, float, const TypeInfo(
        
    
    double
    )

),
      r'double': encodeFormParameter(_repository, double_, const TypeInfo(
        
    
    double
    )

),
      if (string != null) r'string': encodeFormParameter(_repository, string, const TypeInfo(
        
    
    String
    )

),
      r'pattern_without_delimiter': encodeFormParameter(_repository, patternWithoutDelimiter, const TypeInfo(
        
    
    String
    )

),
      r'byte': encodeFormParameter(_repository, byte, const TypeInfo(
        
    
    String
    )

),
      if (binary != null) r'binary': encodeFormParameter(_repository, binary, const TypeInfo(
        
    
    Uint8List
    )

),
      if (date != null) r'date': encodeFormParameter(_repository, date, const TypeInfo(
        
    
    Date
    )

),
      if (dateTime != null) r'dateTime': encodeFormParameter(_repository, dateTime, const TypeInfo(
        
    
    DateTime
    )

),
      if (password != null) r'password': encodeFormParameter(_repository, password, const TypeInfo(
        
    
    String
    )

),
      if (callback != null) r'callback': encodeFormParameter(_repository, callback, const TypeInfo(
        
    
    String
    )

),
    };
    _bodyData = _bodyMap;

    final _response = await rawApi.testEndpointParameters(
      
      body: _bodyData,
      requestContentType: 'application/x-www-form-urlencoded',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// To test enum parameters
  /// To test enum parameters
  ///
  /// Parameters:
  /// * [enumHeaderStringArray] - Header parameter enum test (string array)
  /// * [enumHeaderString] - Header parameter enum test (string) (Default: r&#39;-efg&#39;)  
  /// * [enumQueryStringArray] - Query parameter enum test (string array)
  /// * [enumQueryString] - Query parameter enum test (string) (Default: r&#39;-efg&#39;)  
  /// * [enumQueryInteger] - Query parameter enum test (double)
  /// * [enumQueryDouble] - Query parameter enum test (double)
  /// * [enumQueryModelArray] 
  /// * [enumFormStringArray] - Form parameter enum test (string array) (Default: r&#39;$&#39;)  
  /// * [enumFormString] - Form parameter enum test (string) (Default: r&#39;-efg&#39;)  
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testEnumParameters({ 
    required BuiltList<EnumHeaderStringArrayEnum> enumHeaderStringArray,
     EnumHeaderStringEnum enumHeaderString = r'-efg',
    required BuiltList<EnumQueryStringArrayEnum> enumQueryStringArray,
     EnumQueryStringEnum enumQueryString = r'-efg',
    required EnumQueryIntegerEnum enumQueryInteger,
    required EnumQueryDoubleEnum enumQueryDouble,
    required BuiltList<ModelEnumClass> enumQueryModelArray,
     BuiltList<InnerEnum> enumFormStringArray = r'$',
     EnumFormStringEnum enumFormString = r'-efg',
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    final _bodyMap = <String, dynamic>{
      if (enumFormStringArray != null) r'enum_form_string_array': encodeFormParameter(_repository, enumFormStringArray, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    InnerEnum
    
    )

,
    ])

),
      if (enumFormString != null) r'enum_form_string': encodeFormParameter(_repository, enumFormString, const TypeInfo(
        
    EnumFormStringEnum
    
    )

),
    };
    _bodyData = _bodyMap;

    final _response = await rawApi.testEnumParameters(
      
      enumHeaderStringArray: encodeStringParameter(_repository, enumHeaderStringArray, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    EnumHeaderStringArrayEnum
    
    )

,
    ])

,)!, 
      enumHeaderString: encodeStringParameter(_repository, enumHeaderString, const TypeInfo(
        
    EnumHeaderStringEnum
    
    )

,)!, 
      enumQueryStringArray: encodeQueryParameter(_repository, enumQueryStringArray, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    EnumQueryStringArrayEnum
    
    )

,
    ])

, format: ListFormat.multi,)!,
      enumQueryString: encodeQueryParameter(_repository, enumQueryString, const TypeInfo(
        
    EnumQueryStringEnum
    
    )

, )!,
      enumQueryInteger: encodeQueryParameter(_repository, enumQueryInteger, const TypeInfo(
        
    EnumQueryIntegerEnum
    
    )

, )!,
      enumQueryDouble: encodeQueryParameter(_repository, enumQueryDouble, const TypeInfo(
        
    EnumQueryDoubleEnum
    
    )

, )!,
      enumQueryModelArray: encodeQueryParameter(_repository, enumQueryModelArray, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    ModelEnumClass
    
    )

,
    ])

, format: ListFormat.multi,)!,
      body: _bodyData,
      requestContentType: 'application/x-www-form-urlencoded',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// Fake endpoint to test group parameters (optional)
  /// Fake endpoint to test group parameters (optional)
  ///
  /// Parameters:
  /// * [requiredStringGroup] - Required String in group parameters
  /// * [requiredBooleanGroup] - Required Boolean in group parameters
  /// * [requiredInt64Group] - Required Integer in group parameters
  /// * [stringGroup] - String in group parameters
  /// * [booleanGroup] - Boolean in group parameters
  /// * [int64Group] - Integer in group parameters
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testGroupParameters({ 
    required int requiredStringGroup,
    required bool requiredBooleanGroup,
    required int requiredInt64Group,
    required int stringGroup,
    required bool booleanGroup,
    required int int64Group,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    

    final _response = await rawApi.testGroupParameters(
      
      requiredStringGroup: encodeQueryParameter(_repository, requiredStringGroup, const TypeInfo(
        
    
    int
    )

, )!,
      requiredBooleanGroup: encodeStringParameter(_repository, requiredBooleanGroup, const TypeInfo(
        
    
    bool
    )

,)!, 
      requiredInt64Group: encodeQueryParameter(_repository, requiredInt64Group, const TypeInfo(
        
    
    int
    )

, )!,
      stringGroup: encodeQueryParameter(_repository, stringGroup, const TypeInfo(
        
    
    int
    )

, )!,
      booleanGroup: encodeStringParameter(_repository, booleanGroup, const TypeInfo(
        
    
    bool
    )

,)!, 
      int64Group: encodeQueryParameter(_repository, int64Group, const TypeInfo(
        
    
    int
    )

, )!,

      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// test inline additionalProperties
  /// 
  ///
  /// Parameters:
  /// * [requestBody] - request body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testInlineAdditionalProperties({ 
    required BuiltMap<String, String> requestBody,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    _bodyData = await encodeBodyParameter(_repository, requestBody, const TypeInfo(
    BuiltMap, [
        TypeInfo(String), 
        const TypeInfo(
        
    String
    
    )

,
    ])

);    

    final _response = await rawApi.testInlineAdditionalProperties(
      
      body: _bodyData,
      requestContentType: 'application/json',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// test json serialization of form data
  /// 
  ///
  /// Parameters:
  /// * [param] - field1
  /// * [param2] - field2
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testJsonFormData({ 
    required String param,
    required String param2,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    
    Object? _bodyData;
    final _bodyMap = <String, dynamic>{
      r'param': encodeFormParameter(_repository, param, const TypeInfo(
        
    
    String
    )

),
      r'param2': encodeFormParameter(_repository, param2, const TypeInfo(
        
    
    String
    )

),
    };
    _bodyData = _bodyMap;

    final _response = await rawApi.testJsonFormData(
      
      body: _bodyData,
      requestContentType: 'application/x-www-form-urlencoded',
      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

  /// testQueryParameterCollectionFormat
  /// To test the collection format in query parameters
  ///
  /// Parameters:
  /// * [pipe] 
  /// * [ioutil] 
  /// * [http] 
  /// * [url] 
  /// * [context] 
  /// * [allowEmpty] 
  /// * [language] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testQueryParameterCollectionFormat({ 
    required BuiltList<String> pipe,
    required BuiltList<String> ioutil,
    required BuiltList<String> http,
    required BuiltList<String> url,
    required BuiltList<String> context,
    required String allowEmpty,
    required BuiltMap<String, String> language,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {    

    final _response = await rawApi.testQueryParameterCollectionFormat(
      
      pipe: encodeQueryParameter(_repository, pipe, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    String
    
    )

,
    ])

, format: ListFormat.pipes,)!,
      ioutil: encodeQueryParameter(_repository, ioutil, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    String
    
    )

,
    ])

, format: ListFormat.csv,)!,
      http: encodeQueryParameter(_repository, http, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    String
    
    )

,
    ])

, format: ListFormat.ssv,)!,
      url: encodeQueryParameter(_repository, url, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    String
    
    )

,
    ])

, format: ListFormat.csv,)!,
      context: encodeQueryParameter(_repository, context, const TypeInfo(
    BuiltList, [
        
        const TypeInfo(
        
    String
    
    )

,
    ])

, format: ListFormat.multi,)!,
      allowEmpty: encodeQueryParameter(_repository, allowEmpty, const TypeInfo(
        
    
    String
    )

, )!,
      language: encodeQueryParameter(_repository, language, const TypeInfo(
    BuiltMap, [
        TypeInfo(String), 
        const TypeInfo(
        
    String
    
    )

,
    ])

, )!,

      cancelToken: cancelToken,
      headers: headers,
      extra: extra,
      validateStatus: validateStatus,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );    

    return _response;
  }

}
class FakeApiRaw {

  final Dio _dio;

  const FakeApiRaw(this._dio);

  /// Health check endpoint
  /// 
  ///
  /// Parameters:
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [HealthCheckResult] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> fakeHealthGet({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/health';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// test http signature authentication
  /// 
  ///
  /// Parameters:
  /// * [pet] - Pet object that needs to be added to the store
  /// * [query1] - query parameter
  /// * [header1] - header parameter
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> fakeHttpSignatureTest({ 
    Object? query1,
    String? header1,
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/http-signature-test';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (header1 != null) r'header_1': header1,
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'signature',
            'name': 'http_signature_test',
          },
        ],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (query1 != null) r'query_1': query1,
    };

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// fakeOuterBooleanSerialize
  /// Test serialization of outer boolean types
  ///
  /// Parameters:
  /// * [body] - Input boolean as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [bool] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> fakeOuterBooleanSerialize({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/outer/boolean';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// fakeOuterCompositeSerialize
  /// Test serialization of object with outer number type
  ///
  /// Parameters:
  /// * [outerComposite] - Input composite as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [OuterComposite] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> fakeOuterCompositeSerialize({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/outer/composite';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// fakeOuterNumberSerialize
  /// Test serialization of outer number types
  ///
  /// Parameters:
  /// * [body] - Input number as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [num] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> fakeOuterNumberSerialize({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/outer/number';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// fakeOuterStringSerialize
  /// Test serialization of outer string types
  ///
  /// Parameters:
  /// * [body] - Input string as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [String] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> fakeOuterStringSerialize({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/outer/string';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// fakePropertyEnumIntegerSerialize
  /// Test serialization of enum (int) properties with examples
  ///
  /// Parameters:
  /// * [outerObjectWithEnumProperty] - Input enum (int) as post body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [OuterObjectWithEnumProperty] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> fakePropertyEnumIntegerSerialize({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/property/enum-int';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// testBodyWithBinary
  /// For this test, the body has to be a binary file.
  ///
  /// Parameters:
  /// * [body] - image to upload
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testBodyWithBinary({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/body-with-binary';
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// testBodyWithFileSchema
  /// For this test, the body for this request must reference a schema named &#x60;File&#x60;.
  ///
  /// Parameters:
  /// * [fileSchemaTestClass] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testBodyWithFileSchema({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/body-with-file-schema';
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// testBodyWithQueryParams
  /// 
  ///
  /// Parameters:
  /// * [query] 
  /// * [user] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testBodyWithQueryParams({ 
    required Object query,
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/body-with-query-params';
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'query': query,
    };

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// To test \&quot;client\&quot; model
  /// To test \&quot;client\&quot; model
  ///
  /// Parameters:
  /// * [modelClient] - client model
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [ModelClient] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Object>> testClientModel({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake';
    final _options = Options(
      method: r'PATCH',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
  /// Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
  ///
  /// Parameters:
  /// * [number] - None
  /// * [double_] - None
  /// * [patternWithoutDelimiter] - None
  /// * [byte] - None
  /// * [integer] - None
  /// * [int32] - None
  /// * [int64] - None
  /// * [float] - None
  /// * [string] - None
  /// * [binary] - None
  /// * [date] - None
  /// * [dateTime] - None
  /// * [password] - None
  /// * [callback] - None
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testEndpointParameters({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'basic',
            'name': 'http_basic_test',
          },
        ],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// To test enum parameters
  /// To test enum parameters
  ///
  /// Parameters:
  /// * [enumHeaderStringArray] - Header parameter enum test (string array)
  /// * [enumHeaderString] - Header parameter enum test (string) (Default: r&#39;-efg&#39;)  
  /// * [enumQueryStringArray] - Query parameter enum test (string array)
  /// * [enumQueryString] - Query parameter enum test (string) (Default: r&#39;-efg&#39;)  
  /// * [enumQueryInteger] - Query parameter enum test (double)
  /// * [enumQueryDouble] - Query parameter enum test (double)
  /// * [enumQueryModelArray] 
  /// * [enumFormStringArray] - Form parameter enum test (string array) (Default: r&#39;$&#39;)  
  /// * [enumFormString] - Form parameter enum test (string) (Default: r&#39;-efg&#39;)  
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testEnumParameters({ 
    String? enumHeaderStringArray,
    String? enumHeaderString,
    Object? enumQueryStringArray,
    Object? enumQueryString,
    Object? enumQueryInteger,
    Object? enumQueryDouble,
    Object? enumQueryModelArray,
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (enumHeaderStringArray != null) r'enum_header_string_array': enumHeaderStringArray,
        if (enumHeaderString != null) r'enum_header_string': enumHeaderString,
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (enumQueryStringArray != null) r'enum_query_string_array': enumQueryStringArray,
      if (enumQueryString != null) r'enum_query_string': enumQueryString,
      if (enumQueryInteger != null) r'enum_query_integer': enumQueryInteger,
      if (enumQueryDouble != null) r'enum_query_double': enumQueryDouble,
      if (enumQueryModelArray != null) r'enum_query_model_array': enumQueryModelArray,
    };

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// Fake endpoint to test group parameters (optional)
  /// Fake endpoint to test group parameters (optional)
  ///
  /// Parameters:
  /// * [requiredStringGroup] - Required String in group parameters
  /// * [requiredBooleanGroup] - Required Boolean in group parameters
  /// * [requiredInt64Group] - Required Integer in group parameters
  /// * [stringGroup] - String in group parameters
  /// * [booleanGroup] - Boolean in group parameters
  /// * [int64Group] - Integer in group parameters
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testGroupParameters({ 
    required Object requiredStringGroup,
    required String requiredBooleanGroup,
    required Object requiredInt64Group,
    Object? stringGroup,
    String? booleanGroup,
    Object? int64Group,
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake';
    final _options = Options(
      method: r'DELETE',
      headers: <String, dynamic>{
        r'required_boolean_group': requiredBooleanGroup,
        if (booleanGroup != null) r'boolean_group': booleanGroup,
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer_test',
          },
        ],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'required_string_group': requiredStringGroup,
      r'required_int64_group': requiredInt64Group,
      if (stringGroup != null) r'string_group': stringGroup,
      if (int64Group != null) r'int64_group': int64Group,
    };

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// test inline additionalProperties
  /// 
  ///
  /// Parameters:
  /// * [requestBody] - request body
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testInlineAdditionalProperties({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/inline-additionalProperties';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// test json serialization of form data
  /// 
  ///
  /// Parameters:
  /// * [param] - field1
  /// * [param2] - field2
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testJsonFormData({ 
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/jsonFormData';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

  /// testQueryParameterCollectionFormat
  /// To test the collection format in query parameters
  ///
  /// Parameters:
  /// * [pipe] 
  /// * [ioutil] 
  /// * [http] 
  /// * [url] 
  /// * [context] 
  /// * [allowEmpty] 
  /// * [language] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> testQueryParameterCollectionFormat({ 
    required Object pipe,
    required Object ioutil,
    required Object http,
    required Object url,
    required Object context,
    required Object allowEmpty,
    Object? language,
    Object? body,
    String? requestContentType,
    String? acceptContentType,
    ResponseType? responseType,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/fake/test-query-parameters';
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        if (acceptContentType != null) 'Accept': acceptContentType,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[],
        ...?extra,
      },
      contentType: requestContentType,
      responseType: responseType,
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'pipe': pipe,
      r'ioutil': ioutil,
      r'http': http,
      r'url': url,
      r'context': context,
      if (language != null) r'language': language,
      r'allowEmpty': allowEmpty,
    };

    return await _dio.request<Object>(
      _path,
      data: body,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );
  }

}




























class EnumHeaderStringArrayEnum extends EnumClass {

  @BuiltValueEnumConst(wireName: r'>')
  static const EnumHeaderStringArrayEnum greaterThan = _$enumHeaderStringArrayEnum_greaterThan;
  @BuiltValueEnumConst(wireName: r'$')
  static const EnumHeaderStringArrayEnum dollar = _$enumHeaderStringArrayEnum_dollar;
  @BuiltValueEnumConst(wireName: r'unknown_default_open_api', fallback: true)
  static const EnumHeaderStringArrayEnum unknownDefaultOpenApi = _$enumHeaderStringArrayEnum_unknownDefaultOpenApi;

  static Serializer<EnumHeaderStringArrayEnum> get serializer => _$enumHeaderStringArrayEnumSerializer;

  const EnumHeaderStringArrayEnum._(String name): super(name);

  static BuiltSet<EnumHeaderStringArrayEnum> get values => _$enumHeaderStringArrayEnumValues;
  static EnumHeaderStringArrayEnum valueOf(String name) => _$enumHeaderStringArrayEnumValueOf(name);
}


class EnumHeaderStringEnum extends EnumClass {

  /// Header parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'_abc')
  static const EnumHeaderStringEnum abc = _$enumHeaderStringEnum_abc;
  /// Header parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'-efg')
  static const EnumHeaderStringEnum efg = _$enumHeaderStringEnum_efg;
  /// Header parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'(xyz)')
  static const EnumHeaderStringEnum leftParenthesisXyzRightParenthesis = _$enumHeaderStringEnum_leftParenthesisXyzRightParenthesis;
  /// Header parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'unknown_default_open_api', fallback: true)
  static const EnumHeaderStringEnum unknownDefaultOpenApi = _$enumHeaderStringEnum_unknownDefaultOpenApi;

  static Serializer<EnumHeaderStringEnum> get serializer => _$enumHeaderStringEnumSerializer;

  const EnumHeaderStringEnum._(String name): super(name);

  static BuiltSet<EnumHeaderStringEnum> get values => _$enumHeaderStringEnumValues;
  static EnumHeaderStringEnum valueOf(String name) => _$enumHeaderStringEnumValueOf(name);
}

class EnumQueryStringArrayEnum extends EnumClass {

  @BuiltValueEnumConst(wireName: r'>')
  static const EnumQueryStringArrayEnum greaterThan = _$enumQueryStringArrayEnum_greaterThan;
  @BuiltValueEnumConst(wireName: r'$')
  static const EnumQueryStringArrayEnum dollar = _$enumQueryStringArrayEnum_dollar;
  @BuiltValueEnumConst(wireName: r'unknown_default_open_api', fallback: true)
  static const EnumQueryStringArrayEnum unknownDefaultOpenApi = _$enumQueryStringArrayEnum_unknownDefaultOpenApi;

  static Serializer<EnumQueryStringArrayEnum> get serializer => _$enumQueryStringArrayEnumSerializer;

  const EnumQueryStringArrayEnum._(String name): super(name);

  static BuiltSet<EnumQueryStringArrayEnum> get values => _$enumQueryStringArrayEnumValues;
  static EnumQueryStringArrayEnum valueOf(String name) => _$enumQueryStringArrayEnumValueOf(name);
}


class EnumQueryStringEnum extends EnumClass {

  /// Query parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'_abc')
  static const EnumQueryStringEnum abc = _$enumQueryStringEnum_abc;
  /// Query parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'-efg')
  static const EnumQueryStringEnum efg = _$enumQueryStringEnum_efg;
  /// Query parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'(xyz)')
  static const EnumQueryStringEnum leftParenthesisXyzRightParenthesis = _$enumQueryStringEnum_leftParenthesisXyzRightParenthesis;
  /// Query parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'unknown_default_open_api', fallback: true)
  static const EnumQueryStringEnum unknownDefaultOpenApi = _$enumQueryStringEnum_unknownDefaultOpenApi;

  static Serializer<EnumQueryStringEnum> get serializer => _$enumQueryStringEnumSerializer;

  const EnumQueryStringEnum._(String name): super(name);

  static BuiltSet<EnumQueryStringEnum> get values => _$enumQueryStringEnumValues;
  static EnumQueryStringEnum valueOf(String name) => _$enumQueryStringEnumValueOf(name);
}

class EnumQueryIntegerEnum extends EnumClass {

  /// Query parameter enum test (double)
  @BuiltValueEnumConst(wireNumber: 1)
  static const EnumQueryIntegerEnum number1 = _$enumQueryIntegerEnum_number1;
  /// Query parameter enum test (double)
  @BuiltValueEnumConst(wireNumber: -2)
  static const EnumQueryIntegerEnum numberNegative2 = _$enumQueryIntegerEnum_numberNegative2;
  /// Query parameter enum test (double)
  @BuiltValueEnumConst(wireNumber: 11184809, fallback: true)
  static const EnumQueryIntegerEnum unknownDefaultOpenApi = _$enumQueryIntegerEnum_unknownDefaultOpenApi;

  static Serializer<EnumQueryIntegerEnum> get serializer => _$enumQueryIntegerEnumSerializer;

  const EnumQueryIntegerEnum._(String name): super(name);

  static BuiltSet<EnumQueryIntegerEnum> get values => _$enumQueryIntegerEnumValues;
  static EnumQueryIntegerEnum valueOf(String name) => _$enumQueryIntegerEnumValueOf(name);
}

class EnumQueryDoubleEnum extends EnumClass {

  /// Query parameter enum test (double)
  @BuiltValueEnumConst(wireName: r'1.1')
  static const EnumQueryDoubleEnum number1Period1 = _$enumQueryDoubleEnum_number1Period1;
  /// Query parameter enum test (double)
  @BuiltValueEnumConst(wireName: r'-1.2')
  static const EnumQueryDoubleEnum numberNegative1Period2 = _$enumQueryDoubleEnum_numberNegative1Period2;
  /// Query parameter enum test (double)
  @BuiltValueEnumConst(wireName: r'11184809', fallback: true)
  static const EnumQueryDoubleEnum unknownDefaultOpenApi = _$enumQueryDoubleEnum_unknownDefaultOpenApi;

  static Serializer<EnumQueryDoubleEnum> get serializer => _$enumQueryDoubleEnumSerializer;

  const EnumQueryDoubleEnum._(String name): super(name);

  static BuiltSet<EnumQueryDoubleEnum> get values => _$enumQueryDoubleEnumValues;
  static EnumQueryDoubleEnum valueOf(String name) => _$enumQueryDoubleEnumValueOf(name);
}


class InnerEnum extends EnumClass {


  static Serializer<InnerEnum> get serializer => _$innerEnumSerializer;

  const InnerEnum._(String name): super(name);

  static BuiltSet<InnerEnum> get values => _$innerEnumValues;
  static InnerEnum valueOf(String name) => _$innerEnumValueOf(name);
}


class EnumFormStringEnum extends EnumClass {

  /// Form parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'_abc')
  static const EnumFormStringEnum abc = _$enumFormStringEnum_abc;
  /// Form parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'-efg')
  static const EnumFormStringEnum efg = _$enumFormStringEnum_efg;
  /// Form parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'(xyz)')
  static const EnumFormStringEnum leftParenthesisXyzRightParenthesis = _$enumFormStringEnum_leftParenthesisXyzRightParenthesis;
  /// Form parameter enum test (string)
  @BuiltValueEnumConst(wireName: r'unknown_default_open_api', fallback: true)
  static const EnumFormStringEnum unknownDefaultOpenApi = _$enumFormStringEnum_unknownDefaultOpenApi;

  static Serializer<EnumFormStringEnum> get serializer => _$enumFormStringEnumSerializer;

  const EnumFormStringEnum._(String name): super(name);

  static BuiltSet<EnumFormStringEnum> get values => _$enumFormStringEnumValues;
  static EnumFormStringEnum valueOf(String name) => _$enumFormStringEnumValueOf(name);
}


















