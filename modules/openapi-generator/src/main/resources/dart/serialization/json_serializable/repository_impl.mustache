import 'dart:convert';
import 'dart:typed_data';
import 'repository_base.dart';
import 'package:{{pubName}}/models.dart';

class JsonSerializableRepository extends SerializationRepositoryBase {
    JsonSerializableRepository();
    
    @override
    Object serialize<T>(T src, TypeInfo inputTypeInfo, {Object? context}) {
        return jsonEncode(src);
    }

    /*  ReturnType deserialize<ReturnType, BaseType>(dynamic value, String targetType, {bool growable= true}) {     }*/   
    @override
    T deserialize<T>(Object value, TypeInfo targetTypeInfo, {Object? context}) {
        //Dio automatically calls jsonDecode if the value is a string
        if (value is String) {
            value = jsonDecode(value);
        }
        switch (targetTypeInfo.root) {
            case String:
                return valueString as T;
            case int:
                return (value is num ? value.toInt() : int.parse(value.toString())) as T;
            case bool:
                if (value is bool) {
                    return value as T;
                }
                final valueString = value.toString().toLowerCase();
                return (valueString == 'true' || valueString == '1') as T;
            case double:
                return (value is num ? value.toDouble() : double.parse(value.toString())) as T;
            //TODO: add support for DateTime?
            {{#models}}
            {{#model}}
            case {{{classname}}}:
                {{#isEnum}}
            {{#native_serialization}}return {{{classname}}}TypeTransformer().decode(value);{{/native_serialization}}
            {{#json_serializable}} return _$enumDecode(_${{{classname}}}EnumMap, value);{{/json_serializable}}
                {{/isEnum}}
                {{^isEnum}}
            return {{{classname}}}.fromJson(value as Map<String, dynamic>) as T;
                {{/isEnum}}
            {{/model}}
            {{/models}}
            default:
            RegExpMatch? match;

            if (value is List && (match = _regList.firstMatch(targetTypeInfo)) != null) {
                targetType = match![1]!; // ignore: parameter_assignments
                return value
                .map<BaseType>((dynamic v) => deserialize<BaseType, BaseType>(v, targetTypeInfo, growable: growable))
                .toList(growable: growable) as T;
            }
            if (value is Set && (match = _regSet.firstMatch(targetType)) != null) {
                targetType = match![1]!; // ignore: parameter_assignments
                return value
                .map<BaseType>((dynamic v) => deserialize<BaseType, BaseType>(v, targetTypeInfo, growable: growable))
                .toSet() as T;
            }
            if (value is Map && (match = _regMap.firstMatch(targetType)) != null) {
                targetType = match![1]!; // ignore: parameter_assignments
                return Map<dynamic, BaseType>.fromIterables(
                value.keys,
                value.values.map((dynamic v) => deserialize<BaseType, BaseType>(v, targetTypeInfo, growable: growable)),
                ) as T;
            }
            break;
        } 
        throw Exception('Cannot deserialize');        
    }

    @override
    Object encodeFormParameter<T>(T src, TypeInfo inputTypeInfo, {Object? context}) {
        return src;
    }

    @override
    Object encodeQueryParameter<T>(T src, TypeInfo inputTypeInfo, {
        Object? context,
    }) {
        return src;
    }

    @override
    String encodeStringParameter<T>(T src, TypeInfo inputTypeInfo, {
        Object? context,
    }) {
        return src.toString();
    }


}