import 'dart:convert';
import 'dart:typed_data';
import 'repository_base.dart';
import 'package:{{pubName}}/models.dart';

class JsonSerializableRepository extends SerializationRepositoryBase {
    JsonSerializableRepository();
    
    @override
    Object serialize<T>(T src, TypeInfo inputTypeInfo, {Object? context}) {
        return jsonEncode(src);
    }

    @override
    T deserialize<T>(Object value, TypeInfo targetTypeInfo, {Object? context}) {
        Object valueParsed;
        if (context == 'decodedJson') {
            //if we are deserializing a decoded json, don't decode it again.
            valueParsed = value;
        } else {
            valueParsed = jsonDecode(value.toString()) as Object;            
        }
        switch (targetTypeInfo.root) {
            case String:
                return valueParsed as T;
            case int:
                return (valueParsed is num ? valueParsed.toInt() : int.parse(valueParsed.toString())) as T;
            case bool:
                if (valueParsed is bool) {
                    return valueParsed as T;
                }
                final valueString = valueParsed.toString().toLowerCase();
                return (valueString == 'true' || valueString == '1') as T;
            case double:
                return (valueParsed is num ? valueParsed.toDouble() : double.parse(valueParsed.toString())) as T;
            //TODO: add support for DateTime?
            {{#models}}
            {{#model}}
            case {{{classname}}}:
                {{#isEnum}}
            {{#native_serialization}}return {{{classname}}}TypeTransformer().decode(valueParsed);{{/native_serialization}}
            {{#json_serializable}} return _$enumDecode(_${{{classname}}}EnumMap, valueParsed);{{/json_serializable}}
                {{/isEnum}}
                {{^isEnum}}
            return {{{classname}}}.fromJson(valueParsed as Map<String, dynamic>) as T;
                {{/isEnum}}
            {{/model}}
            {{/models}}
            default:
            RegExpMatch? match;

            if (valueParsed is List && (match = _regList.firstMatch(targetTypeInfo)) != null) {
                targetType = match![1]!; // ignore: parameter_assignments
                return valueParsed
                .map<BaseType>((dynamic v) => deserialize<BaseType, BaseType>(v, targetTypeInfo, growable: growable))
                .toList(growable: growable) as T;
            }
            if (valueParsed is Set && (match = _regSet.firstMatch(targetType)) != null) {
                targetType = match![1]!; // ignore: parameter_assignments
                return valueParsed
                .map<BaseType>((dynamic v) => deserialize<BaseType, BaseType>(v, targetTypeInfo, growable: growable))
                .toSet() as T;
            }
            if (valueParsed is Map && (match = _regMap.firstMatch(targetType)) != null) {
                targetType = match![1]!; // ignore: parameter_assignments
                return Map<dynamic, BaseType>.fromIterables(
                valueParsed.keys,
                valueParsed.values.map((dynamic v) => deserialize<BaseType, BaseType>(v, targetTypeInfo, growable: growable)),
                ) as T;
            }
            break;
        } 
        throw Exception('Cannot deserialize');        
    }
}