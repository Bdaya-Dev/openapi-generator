class _${{classname}}Serializer implements StructuredSerializer<{{classname}}> {
    @override
    final Iterable<Type> types = const [{{classname}}];

    @override
    final String wireName = r'{{classname}}';

    @override
    Iterable<Object?> serialize(Serializers serializers, {{{classname}}} object,
        {FullType specifiedType = FullType.unspecified}) {
        {{!
            delegate serialization to concrete serializer
        }}
        {{#discriminator}}
        {{#mappedModels}}
        if (object is {{modelName}}) {
            final _serializer = {{modelName}}.serializer as StructuredSerializer<{{modelName}}>;
            return _serializer.serialize(serializers, object, specifiedType: FullType({{modelName}}));
        }
        {{/mappedModels}}
        {{/discriminator}}

        throw UnsupportedError('Discriminator not found for type ${object.runtimeType}');
    }

    @override
    {{classname}} deserialize(Serializers serializers, Iterable<Object?> serialized,
        {FullType specifiedType = FullType.unspecified}) {
        {{#discriminator}}
        final serializedList = serialized.toList();
        final discIndex = serializedList.indexOf('{{propertyName}}') + 1;
        final discValue = serializers.deserialize(serializedList[discIndex]).toString();
        switch (discValue) {
            {{#mappedModels}}
            case '{{mappingName}}':
                final _serializer = {{modelName}}.serializer as StructuredSerializer<{{modelName}}>;
                return _serializer.deserialize(serializers, serialized, specifiedType: FullType({{modelName}}));
            {{/mappedModels}}
        }    
        throw UnsupportedError('Discriminator not found $discValue');
        {{/discriminator}}
    }
}