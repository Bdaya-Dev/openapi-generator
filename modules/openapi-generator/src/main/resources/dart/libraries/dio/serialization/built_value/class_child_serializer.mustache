
{{!
    Generate a custom serializer in order to support combinations of required and nullable.
    By default built_value does not serialize null fields.
}}
class _${{classname}}Serializer implements StructuredSerializer<{{classname}}> {
    @override
    final Iterable<Type> types = const [{{classname}}, _${{classname}}];

    @override
    final String wireName = r'{{classname}}';

    @override
    Iterable<Object?> serialize(Serializers serializers, {{{classname}}} object,
        {FullType specifiedType = FullType.unspecified}) {
        final result = <Object?>[];
        {{#vars}}
        {{#required}}
        {{!
            A required property need to always be part of the serialized output.
            When it is nullable, null is serialized, otherwise it is an error if it is null.
        }}
        result
            ..add(r'{{baseName}}')
            ..add({{#isNullable}}object.{{{name}}} == null ? null : {{/isNullable}}serializers.serialize(object.{{{name}}},
                specifiedType: const {{>serialization/built_value/variable_serializer_type}}));
        {{/required}}
        {{^required}}
        if (object.{{{name}}} != null) {
            {{! Non-required properties are only serialized if not null. }}
            result
                ..add(r'{{baseName}}')
                ..add(serializers.serialize(object.{{{name}}},
                    specifiedType: const {{>serialization/built_value/variable_serializer_type}}));
        }
        {{/required}}
        {{/vars}}
        return result;
    }

    @override
    {{classname}} deserialize(Serializers serializers, Iterable<Object?> serialized,
        {FullType specifiedType = FullType.unspecified}) {
        final result = {{classname}}Builder();

        final iterator = serialized.iterator;
        while (iterator.moveNext()) {
            final key = iterator.current as String;
            iterator.moveNext();
            final Object? value = iterator.current;
            
            switch (key) {
                {{#vars}}
                case r'{{baseName}}':
                    final valueDes = serializers.deserialize(value,
                        specifiedType: const {{>serialization/built_value/variable_serializer_type}}) as {{>serialization/built_value/variable_type}};
                    {{#isNullable}}
                    if (valueDes == null) continue;
                    {{/isNullable}}
                    {{#isContainer}}
                    result.{{{name}}}.replace(valueDes);
                    {{/isContainer}}
                    {{^isContainer}}
                    {{#isEnum}}
                    result.{{{name}}} = valueDes;
                    {{/isEnum}}
                    {{^isEnum}}
                    {{#isModel}}
                    {{#isPrimitiveType}}
                    {{! These are models that have been manually marked as primitive via generator param. }}
                    result.{{{name}}} = valueDes;
                    {{/isPrimitiveType}}
                    {{^isPrimitiveType}}
                    result.{{{name}}}.replace(valueDes);
                    {{/isPrimitiveType}}
                    {{/isModel}}
                    {{^isModel}}
                    result.{{{name}}} = valueDes;
                    {{/isModel}}
                    {{/isEnum}}
                    {{/isContainer}}
                    break;
                {{/vars}}
            }
        }
        return result.build();
    }
}
